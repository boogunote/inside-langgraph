查找这些方法在实际代码中的使用示例：


[4 tools called]


查看一些测试文件以获取更具体的示例：


[2 tools called]


以下是这四个方法的适用场景与示例：

## 1. `stream()` - 同步流式执行

### 适用场景
- 需要实时查看执行进度
- 代码环境是同步的（非 async/await）
- 需要逐步处理中间结果
- 调试和监控执行过程

### 具体例子

#### 例子 1: 实时显示 Agent 执行进度
```python
from langgraph.prebuilt import create_react_agent
from langchain_anthropic import ChatAnthropic

# 创建 agent
agent = create_react_agent(
    model=ChatAnthropic(model="claude-3-5-sonnet-20241022"),
    tools=[get_weather_tool],
)

# 使用 stream() 实时查看每个步骤
print("开始执行 Agent...")
for chunk in agent.stream(
    {"messages": [{"role": "user", "content": "北京今天天气怎么样？"}]},
    stream_mode="updates"  # 显示每个节点的更新
):
    node_name = list(chunk.keys())[0]
    print(f"✓ 节点 '{node_name}' 执行完成")
    print(f"  输出: {chunk[node_name]}\n")
```

输出示例：
```
开始执行 Agent...
✓ 节点 'agent' 执行完成
  输出: {'messages': [AIMessage(content='', tool_calls=[...])]}

✓ 节点 'tools' 执行完成
  输出: {'messages': [ToolMessage(content='北京今天晴天，25°C')]}

✓ 节点 'agent' 执行完成
  输出: {'messages': [AIMessage(content='北京今天晴天，温度25°C')]}
```

#### 例子 2: Token 级流式输出（打字机效果）
```python
# 实时显示 LLM 生成的每个 token
for token, metadata in agent.stream(
    {"messages": [{"role": "user", "content": "写一首关于春天的诗"}]},
    stream_mode="messages"  # Token 级流式
):
    print(token, end="", flush=True)  # 逐字打印，模拟打字机效果
```

#### 例子 3: 调试模式 - 查看完整执行信息
```python
# 调试时查看详细信息
for chunk in agent.stream(
    {"messages": [{"role": "user", "content": "查询天气"}]},
    stream_mode="debug"  # 显示所有调试信息
):
    print(json.dumps(chunk, indent=2, ensure_ascii=False))
```

#### 例子 4: 批量处理并实时显示进度
```python
def process_multiple_queries(queries):
    """批量处理查询，实时显示每个查询的进度"""
    results = []
    for i, query in enumerate(queries, 1):
        print(f"\n处理查询 {i}/{len(queries)}: {query}")
        chunks = []
        for chunk in agent.stream(
            {"messages": [{"role": "user", "content": query}]},
            stream_mode="values"
        ):
            chunks.append(chunk)
            print(".", end="", flush=True)  # 显示进度点
        results.append(chunks[-1])  # 保存最终结果
        print(" ✓ 完成")
    return results
```

---

## 2. `astream()` - 异步流式执行

### 适用场景
- 需要实时查看执行进度
- 代码环境是异步的（async/await）
- 需要并发处理多个任务
- 在 Web 服务器、异步框架中使用

### 具体例子

#### 例子 1: FastAPI Web 服务器实时流式响应
```python
from fastapi import FastAPI
from fastapi.responses import StreamingResponse
import json

app = FastAPI()

@app.post("/chat/stream")
async def chat_stream(request: ChatRequest):
    """Web API 端点，实时流式返回响应"""
    async def generate():
        async for chunk in agent.astream(
            {"messages": request.messages},
            stream_mode="messages"  # Token 级流式
        ):
            token, metadata = chunk
            # 以 SSE 格式返回
            yield f"data: {json.dumps({'token': token, 'metadata': metadata})}\n\n"
    
    return StreamingResponse(generate(), media_type="text/event-stream")
```

客户端使用：
```javascript
// 前端 JavaScript
const eventSource = new EventSource('/chat/stream');
eventSource.onmessage = (event) => {
    const data = JSON.parse(event.data);
    document.getElementById('output').innerHTML += data.token;
};
```

#### 例子 2: 并发处理多个 Agent 任务
```python
import asyncio

async def process_multiple_agents_concurrently():
    """并发处理多个 agent 任务，每个都实时流式输出"""
    tasks = [
        agent.astream(
            {"messages": [{"role": "user", "content": f"查询任务 {i}"}]},
            stream_mode="updates"
        )
        for i in range(5)
    ]
    
    # 使用 asyncio.gather 并发执行
    async def process_one(stream, task_id):
        print(f"\n任务 {task_id} 开始:")
        async for chunk in stream:
            print(f"  任务 {task_id}: {chunk}")
    
    await asyncio.gather(*[
        process_one(stream, i) 
        for i, stream in enumerate(tasks)
    ])

# 运行
asyncio.run(process_multiple_agents_concurrently())
```

#### 例子 3: 异步 WebSocket 实时通信
```python
from fastapi import WebSocket

@app.websocket("/ws/chat")
async def websocket_chat(websocket: WebSocket):
    await websocket.accept()
    
    while True:
        # 接收用户消息
        data = await websocket.receive_json()
        user_message = data["message"]
        
        # 异步流式返回响应
        async for chunk in agent.astream(
            {"messages": [{"role": "user", "content": user_message}]},
            stream_mode="messages"
        ):
            token, metadata = chunk
            await websocket.send_json({
                "type": "token",
                "token": token,
                "metadata": metadata
            })
        
        # 发送完成信号
        await websocket.send_json({"type": "done"})
```

#### 例子 4: 异步任务队列处理
```python
import asyncio
from asyncio import Queue

async def worker(queue: Queue):
    """异步工作线程，处理队列中的任务"""
    while True:
        task = await queue.get()
        if task is None:
            break
        
        print(f"处理任务: {task['id']}")
        async for chunk in agent.astream(
            task["input"],
            stream_mode="updates"
        ):
            # 实时更新任务状态
            await update_task_status(task["id"], chunk)
        
        queue.task_done()

# 使用
task_queue = asyncio.Queue()
asyncio.create_task(worker(task_queue))
```

---

## 3. `invoke()` - 同步一次性执行

### 适用场景
- 只需要最终结果，不需要中间步骤
- 代码环境是同步的
- 简单的一次性调用
- 脚本、批处理任务

### 具体例子

#### 例子 1: 简单的脚本调用
```python
# 最简单的使用场景：只需要最终答案
result = agent.invoke({
    "messages": [{"role": "user", "content": "1+1等于几？"}]
})

print(f"最终答案: {result['messages'][-1].content}")
# 输出: 最终答案: 1+1等于2
```

#### 例子 2: 批处理任务
```python
def batch_process_queries(queries):
    """批量处理查询，只需要最终结果"""
    results = []
    for query in queries:
        result = agent.invoke({
            "messages": [{"role": "user", "content": query}]
        })
        results.append({
            "query": query,
            "answer": result['messages'][-1].content
        })
    return results

# 使用
queries = ["天气怎么样？", "现在几点？", "今天星期几？"]
results = batch_process_queries(queries)
for r in results:
    print(f"Q: {r['query']}\nA: {r['answer']}\n")
```

#### 例子 3: 单元测试
```python
def test_agent_basic_functionality():
    """测试 agent 的基本功能"""
    result = agent.invoke({
        "messages": [{"role": "user", "content": "测试消息"}]
    })
    
    assert "messages" in result
    assert len(result["messages"]) > 0
    assert result["messages"][-1].content is not None
    print("✓ 测试通过")
```

#### 例子 4: 数据处理管道
```python
def data_processing_pipeline(data_list):
    """数据处理管道，每个步骤只需要最终结果"""
    processed = []
    for data in data_list:
        # 步骤1: 使用 agent 处理
        step1_result = agent.invoke({
            "messages": [{"role": "user", "content": f"处理: {data}"}]
        })
        
        # 步骤2: 提取结果
        extracted = step1_result['messages'][-1].content
        
        # 步骤3: 进一步处理
        final_result = some_other_processing(extracted)
        processed.append(final_result)
    
    return processed
```

#### 例子 5: 命令行工具
```python
# CLI 工具
import sys

def main():
    if len(sys.argv) < 2:
        print("用法: python cli_tool.py '你的问题'")
        return
    
    question = " ".join(sys.argv[1:])
    result = agent.invoke({
        "messages": [{"role": "user", "content": question}]
    })
    
    print(result['messages'][-1].content)

if __name__ == "__main__":
    main()
```

---

## 4. `ainvoke()` - 异步一次性执行

### 适用场景
- 只需要最终结果，不需要中间步骤
- 代码环境是异步的
- 需要并发执行多个任务
- 在异步 Web 框架中使用

### 具体例子

#### 例子 1: FastAPI 异步 API 端点
```python
from fastapi import FastAPI

app = FastAPI()

@app.post("/chat")
async def chat(request: ChatRequest):
    """异步 API 端点，返回最终结果"""
    result = await agent.ainvoke({
        "messages": request.messages
    })
    
    return {
        "response": result['messages'][-1].content,
        "message_count": len(result['messages'])
    }
```

#### 例子 2: 并发处理多个独立任务
```python
async def process_multiple_queries_concurrently(queries):
    """并发处理多个查询，每个只需要最终结果"""
    # 创建多个异步任务
    tasks = [
        agent.ainvoke({
            "messages": [{"role": "user", "content": query}]
        })
        for query in queries
    ]
    
    # 并发执行所有任务
    results = await asyncio.gather(*tasks)
    
    # 处理结果
    return [
        {
            "query": query,
            "answer": result['messages'][-1].content
        }
        for query, result in zip(queries, results)
    ]

# 使用
queries = ["问题1", "问题2", "问题3", "问题4", "问题5"]
results = await process_multiple_queries_concurrently(queries)
```

#### 例子 3: 异步任务调度器
```python
import asyncio
from datetime import datetime

class AsyncTaskScheduler:
    def __init__(self):
        self.tasks = []
    
    async def schedule_task(self, input_data, delay=0):
        """调度一个任务，延迟执行"""
        if delay > 0:
            await asyncio.sleep(delay)
        
        result = await agent.ainvoke(input_data)
        return result
    
    async def run_all_tasks(self):
        """并发执行所有任务"""
        results = await asyncio.gather(*self.tasks)
        return results

# 使用
scheduler = AsyncTaskScheduler()
scheduler.tasks.append(
    scheduler.schedule_task(
        {"messages": [{"role": "user", "content": "任务1"}]},
        delay=1
    )
)
scheduler.tasks.append(
    scheduler.schedule_task(
        {"messages": [{"role": "user", "content": "任务2"}]},
        delay=2
    )
)

results = await scheduler.run_all_tasks()
```

#### 例子 4: 异步数据库操作 + Agent 调用
```python
import asyncpg

async def process_user_queries_from_db():
    """从数据库读取查询，异步处理，保存结果"""
    # 连接数据库
    conn = await asyncpg.connect("postgresql://...")
    
    # 获取待处理的查询
    rows = await conn.fetch("SELECT id, query FROM pending_queries")
    
    # 并发处理所有查询
    async def process_one(row):
        result = await agent.ainvoke({
            "messages": [{"role": "user", "content": row["query"]}]
        })
        
        # 保存结果到数据库
        await conn.execute(
            "UPDATE pending_queries SET answer = $1 WHERE id = $2",
            result['messages'][-1].content,
            row["id"]
        )
    
    # 并发执行
    await asyncio.gather(*[process_one(row) for row in rows])
    await conn.close()
```

#### 例子 5: 异步批处理服务
```python
class AsyncBatchProcessor:
    def __init__(self, batch_size=10):
        self.batch_size = batch_size
    
    async def process_batch(self, items):
        """处理一批项目"""
        # 将项目分成批次
        batches = [
            items[i:i+self.batch_size]
            for i in range(0, len(items), self.batch_size)
        ]
        
        all_results = []
        for batch in batches:
            # 并发处理当前批次
            tasks = [
                agent.ainvoke({"messages": [{"role": "user", "content": item}]})
                for item in batch
            ]
            results = await asyncio.gather(*tasks)
            all_results.extend(results)
        
        return all_results

# 使用
processor = AsyncBatchProcessor(batch_size=5)
items = [f"查询{i}" for i in range(20)]
results = await processor.process_batch(items)
```

---

## 方法选择决策树

```
需要实时查看进度？
├─ 是 → 代码是异步的？
│   ├─ 是 → 使用 astream()
│   └─ 否 → 使用 stream()
│
└─ 否 → 代码是异步的？
    ├─ 是 → 需要并发执行多个任务？
    │   ├─ 是 → 使用 ainvoke() + asyncio.gather()
    │   └─ 否 → 使用 ainvoke()
    │
    └─ 否 → 使用 invoke()
```

## 总结对比

| 场景 | 推荐方法 | 原因 |
|------|---------|------|
| Web API 实时流式响应 | `astream()` | 异步 + 实时 |
| 调试和监控 | `stream()` | 同步 + 实时 |
| 简单脚本 | `invoke()` | 同步 + 简单 |
| 并发批处理 | `ainvoke()` | 异步 + 高效 |
| CLI 工具 | `invoke()` | 同步 + 简单 |
| WebSocket 实时通信 | `astream()` | 异步 + 实时 |
| 单元测试 | `invoke()` | 同步 + 简单 |

根据你的具体需求选择合适的方法。