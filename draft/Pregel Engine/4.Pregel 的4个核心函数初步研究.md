## Pregel 类的四个核心执行方法

### 1. `stream()` - 同步流式执行

**位置**: 第 2404-2677 行

**功能**: 同步流式执行图，逐步返回中间结果。

**主要特点**:
- 返回类型: `Iterator[dict[str, Any] | Any]`
- 使用 `SyncQueue` 和 `SyncPregelLoop` 进行同步执行
- 支持多种流模式（`stream_mode`）：
  - `"values"`: 每步后返回完整状态
  - `"updates"`: 仅返回节点更新
  - `"custom"`: 自定义数据流
  - `"messages"`: LLM 消息的 token 级流
  - `"checkpoints"`: 检查点事件
  - `"tasks"`: 任务开始/完成事件
  - `"debug"`: 调试信息
- 支持中断控制（`interrupt_before`、`interrupt_after`）
- 支持持久化模式（`durability`）：
  - `"sync"`: 同步持久化
  - `"async"`: 异步持久化
  - `"exit"`: 退出时持久化

**执行流程**:
```python
1. 创建同步队列 (SyncQueue)
2. 设置回调管理器
3. 配置流模式和检查点
4. 创建 SyncPregelLoop 执行循环
5. 在循环中逐步执行 (while loop.tick())
6. 每步通过 yield 返回结果
7. 处理递归限制和错误
```

### 2. `astream()` - 异步流式执行

**位置**: 第 2678-3019 行

**功能**: 异步流式执行图，逐步返回中间结果。

**主要特点**:
- 返回类型: `AsyncIterator[dict[str, Any] | Any]`
- 使用 `AsyncQueue` 和 `AsyncPregelLoop` 进行异步执行
- 支持与 `stream()` 相同的流模式
- 使用 `asyncio` 进行异步任务管理
- 支持并发流式输出（`stream_eager`）

**执行流程**:
```python
1. 创建异步队列 (AsyncQueue)
2. 获取当前事件循环
3. 设置异步回调管理器
4. 创建 AsyncPregelLoop 执行循环
5. 在异步循环中逐步执行 (while loop.tick())
6. 使用 async for 和 yield 返回结果
7. 处理异步清理和错误
```

**与 `stream()` 的区别**:
- 使用异步队列和循环
- 支持 `asyncio.Task` 管理
- 使用 `call_soon_threadsafe` 进行线程安全操作
- 支持异步检查点等待

### 3. `invoke()` - 同步执行

**位置**: 第 3021-3109 行

**功能**: 同步执行图，返回最终结果。

**主要特点**:
- 返回类型: `dict[str, Any] | Any`
- 内部调用 `stream()` 方法
- 默认 `stream_mode="values"`，返回最终状态
- 收集所有流式输出，返回最后一个值
- 处理中断（`Interrupt`）信息

**执行流程**:
```python
1. 调用 self.stream() 获取流式结果
2. 遍历所有 chunk
3. 如果 stream_mode == "values":
   - 跟踪最新的 "values" 输出
   - 收集所有 "updates" 中的中断信息
   - 返回最终状态（可能包含中断）
4. 否则返回所有 chunk 的列表
```

**使用场景**:
- 需要最终结果，不需要中间步骤
- 简单的一次性执行
- 同步代码环境

### 4. `ainvoke()` - 异步执行

**位置**: 第 3111-3199 行

**功能**: 异步执行图，返回最终结果。

**主要特点**:
- 返回类型: `dict[str, Any] | Any`（异步）
- 内部调用 `astream()` 方法
- 默认 `stream_mode="values"`，返回最终状态
- 使用 `async for` 收集结果

**执行流程**:
```python
1. 调用 self.astream() 获取异步流式结果
2. 使用 async for 遍历所有 chunk
3. 如果 stream_mode == "values":
   - 跟踪最新的 "values" 输出
   - 收集所有 "updates" 中的中断信息
   - 返回最终状态（可能包含中断）
4. 否则返回所有 chunk 的列表
```

**使用场景**:
- 需要最终结果，不需要中间步骤
- 异步代码环境
- 需要与其他异步操作集成

## 方法对比总结

| 方法 | 执行方式 | 返回类型 | 内部实现 | 适用场景 |
|------|---------|---------|---------|---------|
| `stream()` | 同步流式 | `Iterator` | `SyncPregelLoop` | 需要逐步查看执行过程 |
| `astream()` | 异步流式 | `AsyncIterator` | `AsyncPregelLoop` | 异步环境，需要逐步查看 |
| `invoke()` | 同步一次性 | `dict/Any` | 调用 `stream()` | 只需要最终结果 |
| `ainvoke()` | 异步一次性 | `dict/Any` | 调用 `astream()` | 异步环境，只需要最终结果 |

## 核心执行模型

所有方法都遵循 Pregel 算法/BSP 模型：
1. Plan（规划）: 确定要执行的节点
2. Execution（执行）: 并行执行选定的节点
3. Update（更新）: 更新通道值

这个三步循环会重复执行，直到没有更多节点需要执行或达到递归限制。

这些方法提供了从同步到异步、从流式到一次性执行的完整执行接口，适用于不同的使用场景。