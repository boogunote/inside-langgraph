## LangGraph 将 LangChain 作为子节点使用的实现机制
本代码图展示了 LangGraph 如何将 LangChain 作为子节点使用。主要通过继承 LangChain 的 Runnable 接口 [1a]，使用 coerce_to_runnable 函数将各种组件转换为统一的 Runnable 类型 [2c]，以及在图的节点和条件边中使用 LangChain 组件 [3a][4c]。这种设计让 LangGraph 能够无缝集成 LangChain 生态系统，同时提供图结构的编排能力。
### 1. LangGraph 继承 LangChain Runnable 接口
展示 LangGraph 如何通过继承 LangChain 的 Runnable 接口来获得执行能力
### 1a. PregelProtocol 继承 Runnable (`protocol.py:17`)
LangGraph 核心协议继承自 LangChain 的 Runnable 接口
```text
class PregelProtocol(Runnable[InputT, Any], Generic[StateT, ContextT, InputT, OutputT]):
```
### 1b. 导入 LangChain Runnable (`protocol.py:7`)
导入 LangChain 核心的 Runnable 接口
```text
from langchain_core.runnables import Runnable, RunnableConfig
```
### 1c. Pregel 执行引擎 (`main.py:323`)
核心执行引擎实现 PregelProtocol
```text
class Pregel(PregelProtocol[StateT, ContextT, InputT, OutputT],
```
### 1d. 编译后的图继承 Pregel (`state.py:929`)
编译后的图获得执行能力
```text
class CompiledStateGraph(Pregel[StateT, ContextT, InputT, OutputT],
```
### 2. 节点添加时的类型转换
展示 LangGraph 如何将 LangChain 组件转换为可执行的节点
### 2a. 导入 LangChain Runnable (`state.py:25`)
StateGraph 导入 LangChain 的 Runnable
```text
from langchain_core.runnables import Runnable, RunnableConfig
```
### 2b. StateNode 类型定义 (`_node.py:80`)
节点类型包含 LangChain 的 Runnable
```text
| Runnable[NodeInputT, Any]
```
### 2c. 转换节点为 Runnable (`state.py:538`)
添加节点时转换为统一的 Runnable 类型
```text
coerce_to_runnable(action, name=node, trace=False)
```
### 2d. 检查是否为 Runnable (`_runnable.py:512`)
coerce_to_runnable 检查对象类型
```text
if isinstance(thing, Runnable):
```
### 3. LangChain 组件作为图节点使用
展示实际的 LangChain 组件如何在图中作为节点使用
### 3a. 使用 RunnablePick 作为节点 (`test_large_cases_async.py:1427`)
LangChain 的 RunnablePick 与模型组合作为节点
```text
workflow.add_node("agent", {"messages": RunnablePick("messages") | model})
```
### 3b. 导入 LangChain 组件 (`test_large_cases.py:10`)
导入各种 LangChain Runnable 组件
```text
from langchain_core.runnables import RunnableConfig, RunnableMap, RunnablePick
```
### 3c. 使用 RunnableMap 包装 (`test_large_cases.py:3825`)
使用 RunnableMap 包装 LangChain 组件作为节点
```text
"agent", RunnableMap(__root__=RunnablePick("__root__") | model)
```
### 3d. 使用自定义 Runnable (`sequential.py:23`)
使用 LangGraph 自定义的 RunnableCallable
```text
builder.add_node(name, RunnableCallable(noop, anoop))
```
### 4. 条件边中的 LangChain 组件
展示 LangChain 组件如何用于条件路由
### 4a. 条件边支持 Runnable (`state.py:632`)
add_conditional_edges 接受 LangChain Runnable 作为条件
```text
| Runnable[Any, Hashable | Sequence[Hashable]],
```
### 4b. 转换条件为 Runnable (`state.py:664`)
条件函数也被转换为 Runnable
```text
path = coerce_to_runnable(path, name=None, trace=True)
```
### 4c. 使用 RunnablePick 作为条件 (`test_large_cases.py:3833`)
LangChain 组件用于条件路由
```text
RunnablePick("__root__") | should_continue,
```
### 5. 运行时使用 LangChain 组件
展示在图执行过程中如何使用 LangChain 组件
### 5a. 导入 RunnableSequence (`main.py:32`)
执行引擎导入 LangChain 的 RunnableSequence
```text
from langchain_core.runnables import RunnableSequence
```
### 5b. 创建执行序列 (`main.py:1796`)
使用 RunnableSequence 组合多个写入器
```text
run = RunnableSequence(*writers) if len(writers) > 1 else writers[0]
```
### 5c. 执行 Runnable (`main.py:1798`)
调用 LangChain Runnable 执行任务
```text
run.invoke(values, patch_config(
```
### 5d. 查找子图中的 Runnable (`_utils.py:48`)
在工具函数中处理 RunnableSequence
```text
elif isinstance(c, RunnableSequence) or isinstance(c, RunnableSeq):
```