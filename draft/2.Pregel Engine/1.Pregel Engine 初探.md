# LangGraph æ‰§è¡Œå¼•æ“ (Pregel Engine) å­¦ä¹ ç¬”è®°

## ğŸ“š æ¦‚è¿°

æ‰§è¡Œå¼•æ“æ˜¯ LangGraph çš„**å¿ƒè„**ï¼Œå®ç°äº† Google Pregel çš„å›¾è®¡ç®—æ¨¡å‹ï¼ˆSupersteps, Message Passingï¼‰ã€‚å®ƒè´Ÿè´£ç®¡ç†æ•´ä¸ªå›¾çš„æ‰§è¡Œæµç¨‹ï¼ŒåŒ…æ‹¬ä»»åŠ¡è°ƒåº¦ã€çŠ¶æ€æ›´æ–°ã€æ£€æŸ¥ç‚¹ä¿å­˜ç­‰æ ¸å¿ƒåŠŸèƒ½ã€‚

## ğŸ—ï¸ æ ¸å¿ƒæ¶æ„

### 1. Pregel ç±» (`libs/langgraph/langgraph/pregel/main.py`)

`Pregel` ç±»æ˜¯æ‰§è¡Œå¼•æ“çš„å…¥å£ç‚¹ï¼Œå®ƒæä¾›äº†ï¼š
- `stream()` - åŒæ­¥æµå¼æ‰§è¡Œ
- `astream()` - å¼‚æ­¥æµå¼æ‰§è¡Œ
- `invoke()` - åŒæ­¥æ‰§è¡Œ
- `ainvoke()` - å¼‚æ­¥æ‰§è¡Œ

### 2. PregelLoop ç±» (`libs/langgraph/langgraph/pregel/_loop.py`)

`PregelLoop` æ˜¯æ‰§è¡Œå¾ªç¯çš„æ ¸å¿ƒå®ç°ï¼Œæœ‰ä¸¤ä¸ªå…·ä½“å®ç°ï¼š
- `SyncPregelLoop` - åŒæ­¥ç‰ˆæœ¬
- `AsyncPregelLoop` - å¼‚æ­¥ç‰ˆæœ¬

## ğŸ”‘ å…³é”®æ–¹æ³•è¯¦è§£

### `tick()` æ–¹æ³• - å¿ƒè„è·³åŠ¨

**ä½ç½®**: `libs/langgraph/langgraph/pregel/_loop.py:459`

è¿™æ˜¯æ‰§è¡Œå¼•æ“çš„**æ ¸å¿ƒæ–¹æ³•**ï¼Œæ¯æ¬¡è°ƒç”¨ä»£è¡¨ä¸€ä¸ª Superstepï¼ˆè¶…çº§æ­¥éª¤ï¼‰ã€‚

#### æ‰§è¡Œæµç¨‹ï¼š

```python
def tick(self) -> bool:
    """æ‰§è¡Œ Pregel å¾ªç¯çš„å•ä¸ªè¿­ä»£
    
    è¿”å›:
        True å¦‚æœéœ€è¦æ›´å¤šè¿­ä»£
    """
    # 1. æ£€æŸ¥è¿­ä»£é™åˆ¶
    if self.step > self.stop:
        self.status = "out_of_steps"
        return False
    
    # 2. å‡†å¤‡ä¸‹ä¸€ä¸ªæ­¥éª¤çš„ä»»åŠ¡
    self.tasks = prepare_next_tasks(
        self.checkpoint,
        self.checkpoint_pending_writes,
        self.nodes,
        self.channels,
        # ... å…¶ä»–å‚æ•°
    )
    
    # 3. å¦‚æœæ²¡æœ‰æ›´å¤šä»»åŠ¡ï¼Œå®Œæˆæ‰§è¡Œ
    if not self.tasks:
        self.status = "done"
        return False
    
    # 4. åŒ¹é…ç¼“å­˜çš„å†™å…¥ï¼ˆå¦‚æœå¯ç”¨ï¼‰
    if self.skip_done_tasks and self.checkpoint_pending_writes:
        self._match_writes(self.tasks)
    
    # 5. æ‰§è¡Œå‰æ£€æŸ¥æ˜¯å¦éœ€è¦ä¸­æ–­
    if self.interrupt_before and should_interrupt(...):
        self.status = "interrupt_before"
        raise GraphInterrupt()
    
    # 6. è¾“å‡ºè°ƒè¯•ä¿¡æ¯
    self._emit("tasks", map_debug_tasks, self.tasks.values())
    
    # 7. è¾“å‡ºå·²ç¼“å­˜çš„ä»»åŠ¡å†™å…¥
    for task in self.tasks.values():
        if task.writes:
            self.output_writes(task.id, task.writes, cached=True)
    
    return True  # ç»§ç»­æ‰§è¡Œ
```

#### å…³é”®æ­¥éª¤è¯´æ˜ï¼š

1. **Planï¼ˆè§„åˆ’ï¼‰**: `prepare_next_tasks()` ç¡®å®šè¿™ä¸€æ­¥è¦æ‰§è¡Œå“ªäº›èŠ‚ç‚¹
2. **Executionï¼ˆæ‰§è¡Œï¼‰**: ä»»åŠ¡åœ¨ `runner.tick()` ä¸­å¹¶è¡Œæ‰§è¡Œï¼ˆåœ¨ `stream()`/`astream()` ä¸­è°ƒç”¨ï¼‰
3. **Updateï¼ˆæ›´æ–°ï¼‰**: `after_tick()` æ–¹æ³•åº”ç”¨å†™å…¥å¹¶æ›´æ–°é€šé“

### `after_tick()` æ–¹æ³• - æ­¥éª¤åå¤„ç†

**ä½ç½®**: `libs/langgraph/langgraph/pregel/_loop.py:538`

åœ¨æ¯ä¸ª Superstep æ‰§è¡Œå®Œæˆåè°ƒç”¨ï¼Œè´Ÿè´£ï¼š

```python
def after_tick(self) -> None:
    # 1. åº”ç”¨å†™å…¥ï¼ˆApply Writesï¼‰
    self.updated_channels = apply_writes(
        self.checkpoint,
        self.channels,
        self.tasks.values(),
        self.checkpointer_get_next_version,
        self.trigger_to_nodes,
    )
    
    # 2. è¾“å‡ºå€¼ï¼ˆå¦‚æœè¾“å‡ºé€šé“è¢«æ›´æ–°ï¼‰
    if not self.updated_channels.isdisjoint(self.output_keys):
        self._emit("values", map_output_values, ...)
    
    # 3. æ¸…é™¤å¾…å¤„ç†çš„å†™å…¥
    self.checkpoint_pending_writes.clear()
    
    # 4. ä¿å­˜æ£€æŸ¥ç‚¹
    self._put_checkpoint({"source": "loop"})
    
    # 5. æ‰§è¡Œåæ£€æŸ¥æ˜¯å¦éœ€è¦ä¸­æ–­
    if self.interrupt_after and should_interrupt(...):
        self.status = "interrupt_after"
        raise GraphInterrupt()
```

### `_emit()` æ–¹æ³• - æµå¼è¾“å‡º

**ä½ç½®**: `libs/langgraph/langgraph/pregel/_loop.py:876`

è´Ÿè´£å°†æ•°æ®å‘é€åˆ°æµå¼è¾“å‡ºï¼š

```python
def _emit(
    self,
    mode: StreamMode,  # è¾“å‡ºæ¨¡å¼ï¼švalues, updates, custom, messages, checkpoints, tasks, debug
    values: Callable[P, Iterator[Any]],  # ç”Ÿæˆå€¼çš„å‡½æ•°
    *args: P.args,
    **kwargs: P.kwargs,
) -> None:
    if self.stream is None:
        return
    
    # æ£€æŸ¥æ˜¯å¦éœ€è¦è¾“å‡ºï¼ˆæ ¹æ® stream_modeï¼‰
    if mode not in self.stream.modes and not debug_remap:
        return
    
    # éå†ç”Ÿæˆçš„å€¼å¹¶å‘é€åˆ°æµ
    for v in values(*args, **kwargs):
        if mode in self.stream.modes:
            self.stream((self.checkpoint_ns, mode, v))
        
        # å¦‚æœæ˜¯ debug æ¨¡å¼ï¼ŒåŒ…è£…è¾“å‡º
        if debug_remap:
            self.stream((self.checkpoint_ns, "debug", {...}))
```

### `stream()` / `astream()` æ–¹æ³• - æµå¼æ‰§è¡Œå…¥å£

**ä½ç½®**: `libs/langgraph/langgraph/pregel/main.py:2404` (stream) å’Œ `2678` (astream)

è¿™ä¸¤ä¸ªæ–¹æ³•å®ç°äº†æµå¼æ‰§è¡Œçš„ä¸»å¾ªç¯ï¼š

#### åŒæ­¥ç‰ˆæœ¬ (`stream`)ï¼š

```python
def stream(self, input, config=None, ...) -> Iterator[dict[str, Any] | Any]:
    # 1. è®¾ç½®æµé˜Ÿåˆ—
    stream = SyncQueue()
    
    # 2. åˆ›å»º PregelLoop
    with SyncPregelLoop(...) as loop:
        # 3. åˆ›å»º Runnerï¼ˆè´Ÿè´£å®é™…æ‰§è¡Œä»»åŠ¡ï¼‰
        runner = PregelRunner(...)
        
        # 4. ä¸»æ‰§è¡Œå¾ªç¯ - è¿™å°±æ˜¯"å¿ƒè„è·³åŠ¨"çš„åœ°æ–¹ï¼
        while loop.tick():  # â† æ¯æ¬¡ tick æ˜¯ä¸€ä¸ª Superstep
            # åŒ¹é…ç¼“å­˜çš„å†™å…¥
            for task in loop.match_cached_writes():
                loop.output_writes(task.id, task.writes, cached=True)
            
            # æ‰§è¡Œä»»åŠ¡ï¼ˆå¹¶è¡Œï¼‰
            for _ in runner.tick(
                [t for t in loop.tasks.values() if not t.writes],
                timeout=self.step_timeout,
                ...
            ):
                # è¾“å‡ºæµå¼æ•°æ®
                yield from _output(...)
            
            # æ­¥éª¤åå¤„ç†ï¼ˆåº”ç”¨å†™å…¥ã€ä¿å­˜æ£€æŸ¥ç‚¹ï¼‰
            loop.after_tick()
            
            # å¦‚æœæ˜¯åŒæ­¥æŒä¹…åŒ–ï¼Œç­‰å¾…æ£€æŸ¥ç‚¹ä¿å­˜å®Œæˆ
            if durability_ == "sync":
                loop._put_checkpoint_fut.result()
```

#### å¼‚æ­¥ç‰ˆæœ¬ (`astream`)ï¼š

å¼‚æ­¥ç‰ˆæœ¬çš„ç»“æ„ç±»ä¼¼ï¼Œä½†ä½¿ç”¨ï¼š
- `AsyncPregelLoop` è€Œä¸æ˜¯ `SyncPregelLoop`
- `await loop.amatch_cached_writes()` 
- `async for _ in runner.atick(...)`

## ğŸ”„ æ‰§è¡Œæµç¨‹æ€»è§ˆ

```
è¾“å…¥ â†’ stream()/astream()
  â†“
åˆ›å»º PregelLoop (SyncPregelLoop/AsyncPregelLoop)
  â†“
è¿›å…¥ä¸»å¾ªç¯:
  â”œâ”€ loop.tick()          â† Plan: å‡†å¤‡ä»»åŠ¡
  â”‚   â”œâ”€ prepare_next_tasks()
  â”‚   â”œâ”€ _match_writes()   â† åŒ¹é…ç¼“å­˜
  â”‚   â””â”€ è¿”å› True/False
  â”‚
  â”œâ”€ runner.tick()        â† Execute: æ‰§è¡Œä»»åŠ¡ï¼ˆå¹¶è¡Œï¼‰
  â”‚   â””â”€ æ‰§è¡Œæ‰€æœ‰å‡†å¤‡å¥½çš„ä»»åŠ¡
  â”‚
  â””â”€ loop.after_tick()     â† Update: åº”ç”¨å†™å…¥
      â”œâ”€ apply_writes()    â† åº”ç”¨å†™å…¥åˆ°é€šé“
      â”œâ”€ _emit()          â† æµå¼è¾“å‡º
      â””â”€ _put_checkpoint() â† ä¿å­˜æ£€æŸ¥ç‚¹
  â†“
é‡å¤ç›´åˆ° loop.tick() è¿”å› False
```

## ğŸ“ å…³é”®æ¦‚å¿µ

### Superstepï¼ˆè¶…çº§æ­¥éª¤ï¼‰

æ¯ä¸ª `tick()` è°ƒç”¨ä»£è¡¨ä¸€ä¸ª Superstepï¼š
- **Step N**: æ‰€æœ‰ä»»åŠ¡å¹¶è¡Œæ‰§è¡Œï¼Œè¯»å– Step N-1 çš„é€šé“å€¼
- **Step N â†’ N+1**: åº”ç”¨å†™å…¥ï¼Œæ›´æ–°é€šé“
- **Step N+1**: æ‰€æœ‰ä»»åŠ¡è¯»å–æ›´æ–°åçš„é€šé“å€¼

è¿™ç¡®ä¿äº†**é€šé“åœ¨æ­¥éª¤å†…æ˜¯ä¸å¯å˜çš„**ï¼Œåªæœ‰åœ¨æ­¥éª¤ä¹‹é—´æ‰ä¼šæ›´æ–°ã€‚

### é€šé“æ›´æ–°å¯è§æ€§

- Step N çš„å†™å…¥åœ¨ Step N+1 æ‰å¯è§
- è¿™ä¿è¯äº† BSPï¼ˆBulk Synchronous Parallelï¼‰æ¨¡å‹çš„æ­£ç¡®æ€§

### æ£€æŸ¥ç‚¹ï¼ˆCheckpointingï¼‰

- `_put_checkpoint()` åœ¨æ¯ä¸ªæ­¥éª¤åä¿å­˜çŠ¶æ€
- æ”¯æŒä¸‰ç§æŒä¹…åŒ–æ¨¡å¼ï¼š
  - `"sync"`: åŒæ­¥ä¿å­˜ï¼ˆç­‰å¾…å®Œæˆï¼‰
  - `"async"`: å¼‚æ­¥ä¿å­˜ï¼ˆä¸é˜»å¡ï¼‰
  - `"exit"`: ä»…åœ¨é€€å‡ºæ—¶ä¿å­˜

### æµå¼è¾“å‡ºæ¨¡å¼

`_emit()` æ”¯æŒå¤šç§è¾“å‡ºæ¨¡å¼ï¼š
- `"values"`: è¾“å‡ºçŠ¶æ€å€¼
- `"updates"`: è¾“å‡ºèŠ‚ç‚¹æ›´æ–°
- `"custom"`: è‡ªå®šä¹‰è¾“å‡º
- `"messages"`: LLM æ¶ˆæ¯ï¼ˆtoken-by-tokenï¼‰
- `"checkpoints"`: æ£€æŸ¥ç‚¹äº‹ä»¶
- `"tasks"`: ä»»åŠ¡äº‹ä»¶
- `"debug"`: è°ƒè¯•ä¿¡æ¯

## ğŸ¯ å­¦ä¹ è¦ç‚¹æ€»ç»“

1. **`PregelLoop.tick()`** æ˜¯æ ¸å¿ƒï¼Œæ¯æ¬¡è°ƒç”¨ä»£è¡¨ä¸€ä¸ª Superstep
2. **`stream()`/`astream()`** æ˜¯æ‰§è¡Œå…¥å£ï¼ŒåŒ…å«ä¸»å¾ªç¯
3. **`_emit()`** è´Ÿè´£æµå¼è¾“å‡ºï¼Œæ”¯æŒå¤šç§æ¨¡å¼
4. **BSP æ¨¡å‹**ï¼šæ­¥éª¤å†…å¹¶è¡Œï¼Œæ­¥éª¤é—´åŒæ­¥
5. **é€šé“ä¸å¯å˜æ€§**ï¼šæ­¥éª¤å†…é€šé“å€¼ä¸å˜ï¼Œåªåœ¨æ­¥éª¤é—´æ›´æ–°

## ğŸ” ä»£ç é˜…è¯»å»ºè®®

1. å…ˆçœ‹ `stream()` æ–¹æ³•ï¼Œç†è§£ä¸»å¾ªç¯ç»“æ„
2. å†çœ‹ `tick()` æ–¹æ³•ï¼Œç†è§£å•ä¸ªæ­¥éª¤çš„é€»è¾‘
3. ç„¶åçœ‹ `after_tick()`ï¼Œç†è§£å†™å…¥åº”ç”¨è¿‡ç¨‹
4. æœ€åçœ‹ `_emit()`ï¼Œç†è§£æµå¼è¾“å‡ºæœºåˆ¶

## ğŸ“– ç›¸å…³æ–‡ä»¶

- `libs/langgraph/langgraph/pregel/main.py` - Pregel ç±»å’Œ stream/astream æ–¹æ³•
- `libs/langgraph/langgraph/pregel/_loop.py` - PregelLoop ç±»å’Œ tick/after_tick/_emit æ–¹æ³•
- `libs/langgraph/langgraph/pregel/_algo.py` - prepare_next_tasks, apply_writes ç­‰ç®—æ³•
- `libs/langgraph/langgraph/pregel/_executor.py` - PregelRunner ä»»åŠ¡æ‰§è¡Œå™¨
