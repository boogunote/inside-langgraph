查看 `PregelLoop` 及其实现（`SyncPregelLoop`、`AsyncPregelLoop`）的代码。


[2 tools called]


查看相关执行器代码，了解它们如何配合工作：


[2 tools called]


## PregelLoop 类详解

### 一、PregelLoop 基类概述

`PregelLoop` 是执行循环的基类，实现了 Pregel 算法的核心执行逻辑。它管理：
- 任务调度与执行
- 状态检查点保存
- 通道（Channel）更新
- 中断处理
- 流式输出

### 二、核心属性

```python
class PregelLoop:
    # 执行状态
    step: int                    # 当前步骤编号
    stop: int                    # 最大步骤限制
    status: Literal[...]         # 执行状态：input, pending, done, interrupt_before, interrupt_after, out_of_steps
    
    # 图结构
    nodes: Mapping[str, PregelNode]              # 所有节点
    channels: Mapping[str, BaseChannel]         # 所有通道
    specs: Mapping[str, BaseChannel | ManagedValueSpec]  # 通道规格
    
    # 检查点相关
    checkpoint: Checkpoint                       # 当前检查点
    checkpoint_pending_writes: list[PendingWrite] # 待写入的更新
    checkpointer: BaseCheckpointSaver | None     # 检查点保存器
    
    # 任务管理
    tasks: dict[str, PregelExecutableTask]       # 当前步骤要执行的任务
    
    # 输入输出
    input: Any | None                           # 输入数据
    output: None | dict[str, Any] | Any         # 输出数据
    stream: StreamProtocol | None                # 流式输出协议
```

### 三、核心方法

#### 1. `tick()` - 执行一个 Superstep

```python
def tick(self) -> bool:
    """执行 Pregel 循环的单个迭代
    
    Returns:
        True 如果还需要更多迭代，False 如果完成
    """
```

执行流程：
1. 检查步骤限制：`if self.step > self.stop`
2. 准备下一批任务：调用 `prepare_next_tasks()` 确定要执行的节点
3. 检查是否完成：如果没有任务，返回 `False`
4. 匹配待写入：将之前的 `pending_writes` 匹配到新任务
5. 检查中断：执行前检查 `interrupt_before`
6. 输出调试信息：发送任务信息到流

#### 2. `after_tick()` - 步骤后处理

```python
def after_tick(self) -> None:
    """在 tick() 之后调用，完成 Superstep 的收尾工作"""
```

执行流程：
1. 应用写入：将任务产生的写入应用到通道
2. 输出值：如果输出通道更新，发送到流
3. 清除待写入：清空 `checkpoint_pending_writes`
4. 保存检查点：调用 `_put_checkpoint()`
5. 检查中断：执行后检查 `interrupt_after`

#### 3. `put_writes()` - 写入通道更新

```python
def put_writes(self, task_id: str, writes: WritesT) -> None:
    """为任务写入数据，这些数据将在下一个 tick 中被读取"""
```

功能：
- 去重特殊通道的写入（最后一个写入生效）
- 处理 NULL 任务的累积写入
- 清理 UntrackedValue 通道的写入（不持久化）
- 异步保存到检查点（如果启用）
- 输出写入到流

#### 4. `accept_push()` - 接受 PUSH 操作

```python
def accept_push(
    self, task: PregelExecutableTask, write_idx: int, call: Call | None = None
) -> PregelExecutableTask | None:
    """接受任务的 PUSH 操作，可能返回一个新任务来启动"""
```

功能：
- 处理任务的 PUSH 操作（动态创建子任务）
- 创建新任务并加入 `tasks`
- 匹配待写入到新任务

### 四、SyncPregelLoop - 同步实现

#### 特点

1. 继承自 `PregelLoop` 和 `AbstractContextManager`
2. 使用 `ExitStack` 管理资源
3. 使用 `BackgroundExecutor` 执行后台任务（线程池）

#### 关键实现差异

```python
class SyncPregelLoop(PregelLoop, AbstractContextManager):
    def __init__(self, ...):
        super().__init__(...)
        self.stack = ExitStack()  # 同步资源管理
        
        # 同步检查点方法
        if checkpointer:
            self.checkpointer_get_next_version = checkpointer.get_next_version
            self.checkpointer_put_writes = checkpointer.put_writes  # 同步方法
```

#### 上下文管理器

```python
def __enter__(self) -> Self:
    # 1. 加载检查点
    if self.checkpointer:
        saved = self.checkpointer.get_tuple(self.checkpoint_config)  # 同步调用
    else:
        saved = None
    
    # 2. 初始化检查点
    if saved is None:
        saved = CheckpointTuple(..., empty_checkpoint(), ...)
    
    # 3. 创建后台执行器（线程池）
    self.submit = self.stack.enter_context(BackgroundExecutor(self.config))
    
    # 4. 从检查点恢复通道
    self.channels, self.managed = channels_from_checkpoint(...)
    
    # 5. 设置中断处理
    self.stack.push(self._suppress_interrupt)
    
    # 6. 处理输入
    self.updated_channels = self._first(...)
    
    return self
```

#### 缓存匹配

```python
def match_cached_writes(self) -> Sequence[PregelExecutableTask]:
    """同步匹配缓存写入"""
    if self.cache is None:
        return ()
    
    # 从缓存中获取已执行任务的写入结果
    for key, values in self.cache.get(tuple(cached)).items():
        task = cached[key]
        task.writes.extend(values)  # 直接使用缓存结果
        matched.append(task)
    
    return matched
```

### 五、AsyncPregelLoop - 异步实现

#### 特点

1. 继承自 `PregelLoop` 和 `AbstractAsyncContextManager`
2. 使用 `AsyncExitStack` 管理资源
3. 使用 `AsyncBackgroundExecutor` 执行后台任务（asyncio）

#### 关键实现差异

```python
class AsyncPregelLoop(PregelLoop, AbstractAsyncContextManager):
    def __init__(self, ...):
        super().__init__(...)
        self.stack = AsyncExitStack()  # 异步资源管理
        
        # 异步检查点方法
        if checkpointer:
            self.checkpointer_get_next_version = checkpointer.get_next_version
            self.checkpointer_put_writes = checkpointer.aput_writes  # 异步方法！
```

#### 异步上下文管理器

```python
async def __aenter__(self) -> Self:
    # 1. 异步加载检查点
    if self.checkpointer:
        saved = await self.checkpointer.aget_tuple(self.checkpoint_config)  # 异步！
    else:
        saved = None
    
    # 2. 创建异步后台执行器（asyncio tasks）
    self.submit = await self.stack.enter_async_context(
        AsyncBackgroundExecutor(self.config)
    )
    
    # ... 其余类似同步版本
    
    return self
```

#### 异步缓存匹配

```python
async def amatch_cached_writes(self) -> Sequence[PregelExecutableTask]:
    """异步匹配缓存写入"""
    if self.cache is None:
        return []
    
    # 异步从缓存获取
    for key, values in (await self.cache.aget(tuple(cached))).items():
        task = cached[key]
        task.writes.extend(values)
        matched.append(task)
    
    return matched
```

#### 异步 PUSH 接受

```python
async def aaccept_push(
    self, task: PregelExecutableTask, write_idx: int, call: Call | None = None
) -> PregelExecutableTask | None:
    """异步接受 PUSH 操作"""
    if pushed := super().accept_push(task, write_idx, call):
        # 异步匹配缓存
        for task in await self.amatch_cached_writes():
            self.output_writes(task.id, task.writes, cached=True)
    return pushed
```

### 六、执行流程对比

#### 同步执行流程（SyncPregelLoop）

```python
with SyncPregelLoop(...) as loop:
    while loop.tick():  # 同步 tick
        # 1. 匹配缓存（同步）
        for task in loop.match_cached_writes():
            loop.output_writes(task.id, task.writes, cached=True)
        
        # 2. 执行任务（同步，使用线程池）
        for _ in runner.tick(loop.tasks.values(), ...):
            yield from _output(...)
        
        # 3. 步骤后处理（同步）
        loop.after_tick()
```

#### 异步执行流程（AsyncPregelLoop）

```python
async with AsyncPregelLoop(...) as loop:
    while loop.tick():  # 同步 tick（但内部使用异步方法）
        # 1. 匹配缓存（异步）
        for task in await loop.amatch_cached_writes():
            loop.output_writes(task.id, task.writes, cached=True)
        
        # 2. 执行任务（异步，使用 asyncio）
        async for _ in runner.atick(loop.tasks.values(), ...):
            yield from _output(...)
        
        # 3. 步骤后处理（同步，但内部调用异步检查点）
        loop.after_tick()
```

### 七、关键区别总结

| 特性 | SyncPregelLoop | AsyncPregelLoop |
|------|----------------|-----------------|
| 上下文管理器 | `AbstractContextManager` | `AbstractAsyncContextManager` |
| 资源管理 | `ExitStack` | `AsyncExitStack` |
| 后台执行器 | `BackgroundExecutor` (线程池) | `AsyncBackgroundExecutor` (asyncio) |
| 检查点写入 | `checkpointer.put_writes()` | `checkpointer.aput_writes()` |
| 检查点获取 | `checkpointer.get_tuple()` | `checkpointer.aget_tuple()` |
| 缓存匹配 | `match_cached_writes()` | `amatch_cached_writes()` |
| PUSH 接受 | `accept_push()` | `aaccept_push()` |
| 检查点保存 | `_checkpointer_put_after_previous()` 使用 `Future` | `_checkpointer_put_after_previous()` 使用 `asyncio.Task` |

### 八、设计模式

1. 模板方法：`PregelLoop` 定义流程，子类实现同步/异步细节
2. 上下文管理器：统一资源管理与清理
3. 策略模式：通过 `submit` 函数注入不同的执行策略（同步/异步）

这两个实现共享核心逻辑（`tick()`, `after_tick()`, `put_writes()` 等），仅在 I/O 和并发处理上不同，保证了代码复用和一致性。