用最简单无向图演示Pregel SSSP，**一步一步**看每一轮发生了什么。

## 超简单图：3个点

```mermaid
graph LR
    S0["S<br/>dist=∞<br/>源点"] -- 连接 --> A0["A<br/>dist=∞"]
    A0 -- 连接 --> B0["B<br/>dist=∞"]
    %% 目标状态标注
    S0 -.->|最终目标: S=0| S0
    A0 -.->|A=1| A0
    B0 -.->|B=2| B0
```


## 第1轮：只有S激活

```mermaid
graph LR
    S1["S<br/>dist=0<br/>**活跃**"] -->|发消息&quot;dist=1&quot;| A1["A<br/>dist=∞<br/>等待消息"]
    S1 -.->|S休眠| S1
    style S1 fill:#ff9999
```

**发生了什么**：
- S知道自己是源点，设置`dist=0`
- S给邻居A发消息：`"我距离源点是0，你到源点是0+1=1"`
- S觉得自己完了，**voteToHalt（休眠）**
- **屏障等待**：所有worker同步

## 第2轮：A收到消息激活

```mermaid
graph LR
    S2[S<br/>dist=0<br/>**休眠**] 
    A2[A<br/>dist=1<br/>**活跃**] -- 发消息(dist=2) --> B2[B<br/>dist=∞<br/>等待消息]
    A2 -.->|A休眠| A2
    style A2 fill:#ff9999
```
/* 注：箭头内容使用 -- 发消息(dist=2) -->，表示 A2 向 B2 发送消息，休眠用虚线自环 */

**发生了什么**：
- A收到S的消息：`"你到源点是1"`
- A更新`dist=1`，给B发消息：`"你到源点是1+1=2"`
- A休眠
- **屏障等待**

## 第3轮：B收到消息

```mermaid
graph LR
    S3[S<br/>dist=0<br/>休眠] 
    A3[A<br/>dist=1<br/>休眠]
    B3[B<br/>dist=2<br/>**活跃**] -.->|B休眠| B3
    style B3 fill:#ff9999
```

**发生了什么**：
- B收到A的消息：`"你到源点是2"`
- B更新`dist=2`
- B没有邻居要通知，**休眠**
- **本轮无新消息** + **所有点都休眠** → **算法结束！**

## 轮次时间轴

```mermaid
sequenceDiagram
    participant S
    participant A
    participant B
    
    Note over S to B: 第1轮
    S->>A: 发消息(dist=1)
    Note over S to B: 屏障等待
    
    Note over S to B: 第2轮  
    A->>B: 发消息(dist=2)
    Note over S to B: 屏障等待
    
    Note over S to B: 第3轮
    B->>B: 无消息发送
    Note over S to B: 全局收敛结束！
```

**核心规律**：
1. **每轮只处理上一轮的消息**
2. **活跃点并行计算** → **发下一轮消息** → **全图屏障同步**
3. **没人发消息+全休眠** = 结束